# Applying manifest blocks

Within a plan, you can use Bolt to apply blocks of Puppet code (manifest blocks) to remote targets. 

Similar to the `puppet apply` command, which applies a standalone Puppet manifest to a local system, the Bolt `apply` command uses manifest blocks to pass code to remote targets from the command line. You can create manifest blocks that use existing content from the Forge, or mix declarative resource configuration via manifest blocks with procedural orchestration and action in a plan. Most features of the Puppet language are available in a manifest block: classes, custom resource types, and functions. For information about what language features aren't supported, see [Manifest block limitations](applying_manifest_blocks.md#).

Manifest blocks require facts to compile. If your plan includes a manifest block, use the `apply_prep` function in your plan before your manifest block. The `apply_prep` function installs the packages necessary to run the Bolt `apply` command and gathers facts by running [facter](https://puppet.com/docs/facter/latest/), making the facts available to the manifest block. The `apply_prep` function also identifies the targets that do not have Puppet agents and runs the `puppet_agent::install` task (from the [puppet_agent module](https://forge.puppet.com/puppetlabs/puppet_agent)).

**Tip:** If you installed Bolt as a Ruby Gem, make sure you have installed the core modules required to use the `puppet apply` command. These modules are listed in the [Bolt GitHub repository](https://github.com/puppetlabs/bolt/blob/master/Puppetfile)and you can install them using a Puppetfile.

**Related information**  

[Configure Bolt to download and install modules](bolt_installing_modules.md#)

[Puppetfile example](https://github.com/puppetlabs/bolt/blob/master/Puppetfile)

[Puppet Forge](https://forge.puppet.com/)

## How manifest blocks are applied

Behind the scenes, Bolt compiles the code in your manifest block (the code wrapped in curly braces that follows the `apply` function) into a catalog. Code is compiled in the following order:

-   Facts gathered from the targets or set in your inventory.
-   Local variables in the plan, such as `$site_content`.
-   [`Vars`](inventory_file_v2.md#title-1541705359297) set in your inventory.

Like the code compiled with the `puppet apply` function, all the variables are generated. As a result, you can reuse code between Bolt and Puppet. Bolt then copies custom module content from the Bolt modulepath to the targets and applies the catalog using Puppet.

After the catalog compiles and is executed successfully on all targets, `apply` returns the reports generated by applying the catalog on each target.

### Options for `apply` action

The `apply` action supports the following options:

-   `_catch_errors => true` returns a `ResultSet` including failed results, rather than failing the plan.
-   `_description => <DESCRIPTION>` adds a description to the apply block, allowing you to distinguish apply blocks.
-   `_noop => true` applies the manifest block in Puppet no-operation mode, returning a report of the changes it would make, but takes no action.
-   `_run_as => <USER>` applies the manifest block as the specified user. (This option is for transports that allow a user to run commands under a different username.)
    ```
    # Preview installing docker as root on $targets.
    apply($targets, _catch_errors => true, _noop => true, _run_as => root) {
       include 'docker'
    }
    ```

### Return value of `apply` action

The `apply` action returns an object type `ResultSet` that contains `ApplyResult` object for each target. For more information on the methods you can call on `$result`, see [Bolt data types](bolt_types_reference.md). 

```
$results = apply($targets) { ... }
$results.each |$result| {
   notice($result.report)
}
```

### Configuring concurrency

Each target requires a separate catalog be compiled with its unique facts and `Vars`. The apply action compiles and applies catalogs in parallel on the Bolt host. Concurrency of catalog compilation is controlled by a `compile-concurrency` config option. This option is limited to twice the number of threads your CPU can run concurrently. Catalog application, on the other hand, uses the Bolt default thread pool controlled by the `concurrency` option.

## Using Hiera data in a manifest block

Use Hiera to separate configuration from context-specific data, where context may be fact-based or the name of a target.

**Note:** Only Hiera version 5 is supported in Bolt.

Hiera is a key-value configuration data lookup system, used for separating data from Puppet code. You use Hiera data to implicitly override default class parameters. You can also explicitly lookup data from Hiera via lookup, for example:

```
plan do_thing() {
  apply('localhost') {
    notice("Some data in Hiera: ${lookup('mydata')}")
  }
}
```

Manifest block compilation can access Hiera data that you add to your Bolt configuration. The default location for Hiera config is `$BOLTDIR/hiera.yaml`; you can change this with the `hiera-config`key in a Bolt config file.

Following the Hiera 5 convention, the default data dir is relative to `hiera.yaml` at `$BOLTDIR/data`. For config file examples, see [Configuring Hiera](https://puppet.com/docs/puppet/latest/hiera_config_yaml_5.html).

If a custom data provider is used (such as `hiera-eyaml`, which allows you to encrypt your data) the gem dependencies must be available to Bolt. See [Install gems with Bolt packages](bolt_installing.md#).

**Related information**  

[Configuring Bolt](configuring_bolt.md)

## Available plan functions

In addition to the standard Puppet functions available to a catalog, such as `lookup`, you can use the following Bolt functions in a manifest block.

-   [`puppetdb_query`](plan_functions.md#)
-   [`puppetdb_facts`](plan_functions.md#)
-   [`facts`](plan_functions.md#)
-   [`vars`](plan_functions.md#)

## Manifest block limitations

Exported resources are not supported in manifest blocks. You must pass exported resources directly instead of exporting and collecting them from PuppetDB. If you need to interact with resources managed during a normal run, use the function `puppetdb_query`.

In addition, the following top-level variables, which exist in normal catalog compilation, are not included during manifest block compilation:

-   `$server_facts`
-   master variables like `$servername`
-   `$environment`

You can optionally set these from a target's `vars`, but they don't have defaults in Bolt.

**Related information**  

[puppetdb_query](plan_functions.md#)

## Create a sample manifest for nginx on Linux

Create a manifest that sets up a web server with nginx, and run it as a plan.

1.  Go to the `site-modules` directory in the default Bolt project directory: `~/.puppetlabs/bolt/site-modules`
1.  Create a module named profiles.
    -   If you use the Puppet Development Kit: `pdk new module profiles`
    -   Otherwise create `~/.puppetlabs/bolt/site-modules/profiles`
1.  Add a `plans` directory to the profiles module.
1.  In the plans directory, create a manifest file called `nginx_install.pp` and add the following code:
    ```
    plan profiles::nginx_install(
         TargetSpec $targets,
         String $site_content = 'hello!',
       ) {
    
         # Install the puppet-agent package if Puppet is not detected.
         # Copy over custom facts from the Bolt modulepath.
         # Run the `facter` command line tool to gather target information.
         $targets.apply_prep
    
         # Compile the manifest block into a catalog
         apply($targets) {
           if($facts['os']['family'] == 'redhat') {
             package { 'epel-release':
               ensure => present,
               before => Package['nginx'],
             }
             $html_dir = '/usr/share/nginx/html'
           } else {
             $html_dir = '/var/www/html'
           }
    
           package {'nginx':
             ensure => present,
           }
    
           file {"${html_dir}/index.html":
             content => $site_content,
             ensure  => file,
           }
    
           service {'nginx':
             ensure  => 'running',
             enable  => 'true',
             require => Package['nginx']
           }
         }
       }
    ```
1.  Run the plan on a target:
    ```
    bolt plan run profiles::nginx_install --targets mytarget.mydomain
    ```
1.  In a web browser, open `mytarget.mydomain`. The page displays the text `hello!`

**Tip:** For complex web server deployments, consider adding the [puppet-nginx](https://forge.puppet.com/puppet/nginx) module.

**Related information**  

[NGINX](https://www.nginx.com/resources/glossary/nginx/)

[Specify targets](running_bolt_commands.md#adding-options-to-bolt-commands)

[Project directories](bolt_project_directories.md#)


## Create a sample manifest for IIS on Windows

Create a manifest that sets up a web server with IIS and run it as a plan.

1.  Go to the `site-modules` directory in the default Bolt project directory: `~/.puppetlabs/bolt/site-modules`
1.  Create a module named profiles.
    -   If you use the Puppet Development Kit: `pdk new module profiles`
    -   Otherwise create `~/.puppetlabs/bolt/site-modules/profiles`
1.  Add a `plans` directory to the profiles module.
1.  Install the IIS dependencies.
    1.  Add the following code to `~/.puppetlabs/bolt/Puppetfile`
        ```
        forge 'http://forge.puppetlabs.com'
        mod 'puppetlabs-iis', '4.3.2'
        mod 'profiles', local: true
        ```
    1.  Run `bolt puppetfile install`
1.  In the plans directory, create a manifest file called `iis_install.pp` and add the following code:
    ```
    plan profiles::iis_install(
         TargetSpec $targets,
         String $site_content = 'hello!',
       ) {
    
         # Install the puppet-agent package if Puppet is not detected. 
         # Copy over custom facts from the Bolt modulepath.
         # Run the `facter` command line tool to gather target information.
         $targets.apply_prep
    
         # Compile the manifest block into a catalog
         return apply($targets, '_catch_errors' => true) {
           $iis_features = ['Web-WebServer','Web-Scripting-Tools']
    
           iis_feature { $iis_features:
             ensure => 'present',
           }
    
           # Delete the default website to prevent a port binding conflict.
           iis_site {'Default Web Site':
             ensure  => absent,
             require => Iis_feature['Web-WebServer'],
           }
    
           iis_site { 'minimal':
             ensure          => 'started',
             physicalpath    => 'c:\\inetpub\\minimal',
             applicationpool => 'DefaultAppPool',
             require         => [
               File['minimal'],
               Iis_site['Default Web Site']
             ],
           }
    
           file { 'minimal':
             ensure => 'directory',
             path   => 'c:\\inetpub\\minimal',
           }
    
           file { 'content':
             ensure  => 'file',
             path    => 'c:\\inetpub\\minimal\\index.html',
             content => $site_content,
           }
         }
       }
    ```
1.  Run the plan on a target:
    ```
    bolt plan run profiles::iis_install --targets mytarget.mydomain --transport winrm
    ```
1.  In a web browser, open `mytarget.mydomain`. The page displays the text `hello!`

**Related information**  

[IIS](https://www.iis.net)

[Specify targets](running_bolt_commands.md#adding-options-to-bolt-commands)

[Project directories](bolt_project_directories.md#)

## Using Puppet device modules from an apply statement

Puppet device modules based on remote transports allow network devices and other targets that can't run a Puppet agent to be managed from a proxy.

**Note:** Support for device modules is experimental and might change in future minor (y) releases.

To use device modules from an apply statement, the devices must be added to the Bolt inventory as remote targets. The `name` of the target will be used to auto-populate the `name`, `uri`, `user`, `password`, `host`, and `port` fields of the remote transport's connnection info. You must set the `remote-transport` option and any other connnection info under the `remote` section of config.

```yaml
targets:
  - name: "https://username:password@panos-device.example.com"
    config:
      transport: remote
      remote:
        remote-transport: panos
```

When you set the `run-on` option with a device module, the puppet-resource_api Gem must be installed with the puppet agent on the proxy target and it must be version 1.8.1 or later.
