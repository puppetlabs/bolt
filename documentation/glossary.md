# Glossary

Definitions of terms used in Bolt documentation.

## agent

The Puppet agent software package, also known as `puppet-agent`.

## apply

Use the `apply` [Bolt plan function](writing_plans.md) to apply a block of Puppet code (also known as a manifest
block) to a target.

Before you can apply a manifest to a target, prepare the target using
the `apply_prep` plan function. See [`apply_prep`](#apply-prep).

ðŸ“– **Related information**

- [Applying Puppet code](https://puppet.com/docs/bolt/latest/applying_manifest_blocks.html)

## apply_prep

A [Bolt plan function](writing_plans.md) that installs the `puppet-agent` package on targets 
if needed and collects facts, including any custom facts found in Bolt's module
path. The `puppet-agent` package and facts are required for an `apply`.

ðŸ“– **Related information**

- [Applying Puppet code](https://puppet.com/docs/bolt/latest/applying_manifest_blocks.html)
- [`apply_prep` example](plan_functions.md#apply-prep)

## catalog

A catalog is a file that describes the desired state of each managed resource on
a target. It is a compilation of all the resources that the Puppet agent applies
to a given target, as well as the relationships between those resources.

Bolt compiles catalogs from manifests and agent-provided data during an
apply. Bolt then serves the compiled catalog to the agent on a target.

Unlike the manifests from which they are compiled, catalogs don't contain any
conditional logic or functions. They are unambiguous, relevant to only a
specific target, and generated by a target.

ðŸ“– **Related information**

- [Catalog compilation](https://puppet.com/docs/puppet/latest/subsystem_catalog_compilation.html#subsystem_catalog_compilation)

## controller

A controller is any device that you use to run Bolt. See [Installing Bolt](bolt_installing.md)
for a list of supported platforms.

## fact

A fact is a piece of information about a target, such as its hostname, IP
address, or operating system. Facts are typically gathered by Puppet's [Facter](#Facter) tool.

## Facter

Facter is a system inventory tool. Facter reads facts about a target, such as
its hostname, IP address, and operating system, and makes them available to
Bolt.

Facter includes many built-in facts, and you can view the names and values for
a particular node by running `bolt task run facts -t mytarget`.

## future

A Future is a custom Puppet data type in Bolt.  

A Future object is returned by the `background()` plan function
and can be passed to the `wait()` plan function
to block on the result of the backgrounded code block.

ðŸ“– **Related information**

- [Background function](plan_functions.md#background)
- [Wait function](plan_functions.md#wait)
- [Future custom type](bolt_types_reference.md#future)

## group

A group is a set of targets and other groups in the inventory and their
associated configuration. Groups provide a way for you to refer to targets
that share a common trait by a simple, human-readable name.

ðŸ“– **Related information**

- [Inventory files](inventory_files.md)

## Hiera

Hiera is a built-in key-value configuration data lookup system, which lets you
separate data from your code.

ðŸ“– **Related information**

- [How to use Hiera](https://puppet.com/docs/puppet/7/hiera_intro.html)
- [Using bolt with Hiera](hiera.md)

## inventory

The inventory describes the targets that you run Bolt commands on, along with
any data and configuration for the targets. Targets in an inventory can belong
to one or more groups, allowing you to share data and configuration across
multiple targets and to specify multiple targets for your Bolt commands without
the need to list each target individually.

In most cases, Bolt loads the inventory from an inventory file in your Bolt
project. The inventory file is a YAML file named `inventory.yaml`. Because Bolt
loads the inventory file from a Bolt project, you must have an existing project
configuration file named `bolt-project.yaml` alongside the inventory file.

ðŸ“– **Related information**

- [Inventory files](inventory_files.md)
- [inventory.yaml fields](bolt_inventory_reference.md)

## log

Bolt supports multiple log levels. You can configure the log level from the 
CLI, or in a project configuration file. Supported logging levels, in order
from most to least information logged, are `trace`, `debug`, `info`, `warn`,
`error`, and `fatal`.

ðŸ“– **Related information**

- [Bolt logs](logs.md)

## manifest

A directory for storing your Puppet code files, known as manifests.

## module

Modules are shareable, reusable packages of Puppet content. They can include
tasks, plans, functions, and other types of content that you can use in your
project. You can download and install modules to your project from the Puppet
Forge or write your own modules. Bolt also ships with several helpful modules
pre-installed that are available to all of your projects.

Bolt makes it easy to manage the modules that your project depends on. You can
use Bolt commands to install a project's modules, add new modules to a project,
and view the modules that are available to the project.

ðŸ“– **Related information**

- [Modules](modules.md)
- [Installing modules](bolt_installing_modules.md)
- [Module structure](module_structure.md)

## modulepath

The modulepath is an ordered list of directories that Bolt loads modules from.
When Bolt runs a command, it automatically loads modules from the modulepath.

While Bolt has a default modulepath, you can also configure your own modulepath,
which can include directories within the project or directories elsewhere on
your system. Regardless of whether your project uses a default or configured
modulepath, Bolt automatically adds directories to the modulepath. This includes
modules containing core Bolt content, which is added to the beginning of the
modulepath, and bundled content, which is added to the end of the modulepath.

Modules loaded from a directory listed earlier in the modulepath take precedence
over modules with the same name loaded from a directory later in the modulepath.
If Bolt finds two modules with the same name in your modulepath, it ignores the
module with the lower precedence and does not print a warning or error message.

## plan

A set of actions that can be combined with other logic.

Plans allow you to do complex operations, such as running multiple actions with
one command, computing values for the input for an action, or running certain
actions based on the results of another action.

You can write a plan in YAML or in the Puppet language, and they can be packaged
as part of a module or project.

ðŸ“– **Related information**

- [Inspecting plans](inspecting_plans.md)
- [Running plans](bolt_running_plans.md)
- [Writing plans in YAML](writing_yaml_plans.md)
- [Writing plans in the Puppet language](writing_plans.md)

## Plan function

Plans written in the Puppet language can use Puppet functions that are built
into Bolt and Puppet, or custom functions

ðŸ“– **Related information**

- [Bolt built-in functions](plan_functions)
- [Puppet built-in functions](https://puppet.com/docs/puppet/7/function.html)
- [More information on custom functions](https://puppet.com/docs/puppet/7/writing_custom_functions.html)

## plugin

Bolt supports the use of plugins to dynamically load information during a Bolt 
run and change how Bolt executes certain actions. Bolt ships with some plugins, 
but you can also create your own plugins or install plugins created by other users.

There are three types of plugins that you can use with Bolt:

- Reference plugins: Use to fetch data from an external source and store it in a static data object.

- Secret plugins: Use to create keys for encryption and decryption, to encrypt plaintext, or to decrypt ciphertext.

- Puppet library plugins: Use to install Puppet libraries on a target when a plan calls the apply_prep function.

ðŸ“– **Related information**

- [Supported plug-ins](supported_plugins.md)
- [Using plug-ins](using_plugins.md)
- [Writing plug-ins](writing_plugins.md)

## project

A Bolt project is a directory that serves as the launching point for Bolt and
allows you to create a shareable orchestration application. Projects typically
include a project configuration file, an inventory file, and any content you use
in your project workflow, such as tasks and plans.

When you run Bolt, it runs in the context of a project. If the directory you run
Bolt from is not a project, Bolt attempts to find a project by traversing the
parent directories. If Bolt is unable to find a project, it runs from the
default project, located at `~/.puppetlabs/bolt`.

A directory is only considered a Bolt project when it has a project
configuration file named `bolt-project.yaml`. Bolt doesn't load project data and
content, including inventory files, unless the data and content are part of a
project.

ðŸ“– **Related information**

- [Bolt projects](projects.md)
- [bolt-project.yaml options](bolt_project_reference.md)

## puppetfile

A puppetfile specifies the modules installed in your project. Bolt manages this
file. Avoid editing it.

ðŸ“– **Related information**

- [Common project files & directories](projects.md#common-files-and-directories-in-a-project)

## target

A target is a device that Bolt connects to and runs actions on. Targets can be
physical, such as servers, or virtual, such as containers or virtual machines.

ðŸ“– **Related information**

- [Inventory files](inventory_files.md)

## task

A task is a single action that you run on targets. You use tasks to make
as-needed changes to remote systems.

Tasks are similar to scripts and can be written in any programming language that
can run on the targets, such as Bash, PowerShell, and Python. Tasks are packaged
within modules or projects, so you can reuse, download and share tasks. Tasks
also have metadata that describes the task, validates input, and controls how
the task runner executes the task.

ðŸ“– **Related information**

- [Inspecting tasks](inspecting_tasks.md)
- [Running tasks](bolt_running_tasks.md)
- [Writing tasks](writing_tasks.md)

## transport

A transport defines the connection method that Bolt uses to connect to a target.
SSH, WinRM, and local are some of the most commonly used transports.

There is a Docker transport that simplifies connecting to Docker containers, 
but the SSH transport is useful for gaining a broader understanding of how Bolt 
inventory files work.

ðŸ“– **Related information**

- [Specify a transport](running_bolt_commands.md#specify-a-transport)
- [Transport config options](bolt_transports_reference.md)

## type

The different custom types that can be used in a Bolt plan. 

ðŸ“– **Related information**
- [Bolt Types](bolt_types_reference.md)

## type alias 

Type aliases provide an alternate name for existing types or lists of types.
These types can be used within a plan, and have all of the attributes and
functions of whichever Puppet type they are set to in the plan.

ðŸ“– **Related information**

- [Type aliases](bolt_types_reference.md#type-aliases)

