# frozen_string_literal: true

require 'spec_helper'
require 'bolt/pal/yaml_plan/transpiler'

describe Bolt::PAL::YamlPlan::Transpiler do
  before :each do
    Puppet[:tasks] = true
  end

  after :each do
    Puppet.settings.send(:clear_everything_for_tests)
  end

  let(:basepath) { File.join(File.dirname(__FILE__), '..', '..', '..', 'fixtures', 'modules', 'yaml', 'plans') }
  let(:transpiler) { Bolt::PAL::YamlPlan::Transpiler.new }

  context 'with a non-yaml plan' do
    it 'errors converting a non-yaml plan' do
      expect {
        transpiler.transpile('mymod/plans/foo.pp')
      }.to raise_error(/You can only convert plans written in yaml/)
    end
  end

  context 'with a private key' do
    let(:basepath) { File.join(File.dirname(__FILE__), '..', '..', '..', 'fixtures', 'modules', 'private', 'plans') }
    let(:plan_path) { File.join(basepath, 'yaml.yaml') }
    let(:expected) { <<~EXP }
    # A plan with a private key
    # WARNING: This is an autogenerated plan. It may not behave as expected.
    # @private true
    plan private::yaml() {
      $print = run_command('echo Initializing', 'localhost')
    }
    EXP

    it 'translates a private setting' do
      expect { transpiler.transpile(plan_path) }.to output(expected).to_stdout
    end
  end

  context 'with complex parameters' do
    let(:plan_path) { File.join(basepath, 'complex_parameters.yaml') }
    let(:expected) { <<~EXP }
    # A plan with complex parameters
    # WARNING: This is an autogenerated plan. It may not behave as expected.
    # @param empty
    # @param mandatory_string
    # @param mandatory_integer
    # @param boolean
    # @param optional_string
    # @param with_default
    plan yaml::complex_parameters(
      $empty,
      String[1, 10] $mandatory_string,
      Integer $mandatory_integer,
      Boolean $boolean,
      Optional[String] $optional_string,
      TargetSpec $with_default = localhost
    ) {
      $print = run_command('echo Initializing', 'localhost')
    }
    EXP

    it 'outputs signature with parameters' do
      expect { transpiler.transpile(plan_path) }.to output(expected).to_stdout
    end
  end

  context 'with duplicate step names' do
    let(:plan_path) { File.join(basepath, 'duplicate_names.yaml') }
    let(:error) { "Duplicate step name or parameter detected: \"foo\"" }

    it 'errors on duplicate step names' do
      expect { transpiler.transpile(plan_path) }
        .to raise_error(Bolt::Error, /#{error}/)
    end
  end

  context 'with invalid puppet plan' do
    let(:plan_path) { File.join(basepath, 'command.yaml') }
    let(:expected) { <<~EXP }
    # WARNING: This is an autogenerated plan. It may not behave as expected.
    # @param targets
    plan yaml::command(
      TargetSpec $targets
    ) {
      $run_command = run_command('echo hello world', $targets)

      return $run_command
    }
    EXP
    let(:err_msg) { 'The converted puppet plan contains invalid puppet code: Syntax error' }

    before :each do
      # Stub calling the original Parser, so `step` parsing succeeds
      allow_any_instance_of(Puppet::Pops::Parser::EvaluatingParser)
        .to receive(:parse_string)
        .and_call_original

      # Raise error when we parse the whole plan
      allow_any_instance_of(Puppet::Pops::Parser::EvaluatingParser)
        .to receive(:parse_string)
        .with(/plan yaml::command\(/)
        .and_raise(Puppet::Error.new("Syntax error"))
    end

    it 'raises an error and prints the plan' do
      expect { transpiler.transpile(plan_path) }
        .to raise_error(SystemExit)
        .and output(/#{err_msg}/)
        .to_stderr
        .and output(expected)
        .to_stdout
    end
  end
end
